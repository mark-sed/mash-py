// EBNF grammar for MASH language used by the parser
// @author: Marek Sedlacek

// Start nonterminal
start : _stmt
      |

// Standalone expression
_stmt : _stmts
      | _END
      | _stmt _END+ _stmt _END*
      |

// Statements without ENDs
_stmts : import
       | _rvalue
       | FLOW_CTRL
       | return
       | raise
       | try
       | assignment
       | op_assign
       | _definition
       | code_block
       | construct

// Importing
import : "import" _list_space_scope
       | "import" space_scope "as" VAR_NAME -> import_as

_list_space_scope : space_scope
                  | _list_space_scope "," space_scope

// Value assignment excluding standalone variable (nil assignment)
assignment : scope_name "=" (_expr|lambda|assignment)
           | VAR_NAME "=" INTERNAL

// Operation and assignment over 1 variable
op_assign : scope_name ASSIGN_OP (_expr|lambda)

// Different assignments
ASSIGN_OP : ("+="|"-="|"*="|"/="|"//="|"%="|"^="|"++=")

// List
list : "[" _expr "," _expr ".." _expr "]" -> range
     | "[" _expr ".." _expr "]" -> range
     | "[" _list_vals "]"
     | "[" (_expr|lambda) ":" list_assig "]"  // List comprehension
     | "[" (_expr|lambda) "if" _expr ":" list_assig "]"  // List comprehension with condition
_list_vals : _list_vals "," (_expr|lambda)
           | (_expr|lambda)
           |
list_assig : VAR_NAME "=" _expr 
           | list_assig "," VAR_NAME "=" _expr

// Dictionary
dict : "{" _dict_val_list "}"
     | "{" "," "}" // Empty dict
_dict_val_list : (_expr|lambda) ":" (_expr|lambda)
              | _dict_val_list "," (_expr|lambda) ":" (_expr|lambda)

// Right side value
_rvalue : silent_expr
        | _expr
        | lambda

silent_expr : "~" _expr

// Expressions using operators
_expr : expr_lor
     | expr_land
     | expr_or
     | expr_and
     | expr_not
     | expr_lte
     | expr_gte
     | expr_gt
     | expr_lt
     | expr_eq
     | expr_neq
     | expr_in
     | expr_cat
     | expr_add
     | expr_sub
     | expr_mul
     | expr_fdiv
     | expr_idiv
     | expr_mod
     | expr_exp
     | expr_neg
     | ternary_if
     | fun_call
     | member
     | scope_name
     | const
     | list
     | dict
     | "(" _expr ")"

expr_lor : _expr "or" _expr
expr_land : _expr "and" _expr
expr_or : _expr "||" _expr  // (_expr | return | FLOW_CTRL | raise)
expr_and : _expr "&&" _expr // (_expr | return | FLOW_CTRL | raise)
expr_not : ("!"|"not") _expr
expr_lte : _expr "<=" _expr
expr_gte : _expr ">=" _expr
expr_gt : _expr ">" _expr
expr_lt : _expr "<" _expr
expr_eq : _expr "==" _expr
expr_neq : _expr "!=" _expr
expr_in : _expr "in" _expr
expr_cat : _expr "++" _expr
expr_add : _expr "+"_expr
expr_sub : _expr "-" _expr
expr_mul : _expr "*" _expr
expr_fdiv : _expr "/" _expr
expr_idiv : _expr "//" _expr
expr_mod : _expr "%" _expr
expr_exp : _expr "^" _expr
expr_neg : "-" _expr
//expr_dec : scope_name"--"

// Constants
const : SIGNED_FLOAT  -> float
      | SIGNED_INT -> int
      | HEX_INT -> hex_int
      | STRING  -> string
      | "r"STRING -> rstring
      | "f"STRING -> fstring
      | "nil"   -> nil
      | "true"  -> true
      | "false" -> false

// Ternary if
ternary_if : _expr "?" (_expr|lambda) ":" (_expr|lambda)
           //| "if" "(" _expr ")" (_expr|lambda) "else" (_expr|lambda) // Is the same as normal if

// Member
member : _pmember
       | _pslice -> slice
       | _pslice -> slice

_pmember : "(" _pmember ")"
         | _expr "[" _expr "]"

_pslice : "(" _pslice ")"
        | _expr "[" _expr? MEM_SEP _expr? "]"
        | _expr "[" _expr? MEM_SEP _expr? MEM_SEP _expr? "]"

MEM_SEP : ":"

// Definitions
_definition : lambda
           | function
           | space
           | class
           | enum

// Function call
fun_call : scope_name "(" fun_call_args ")" _END?
         | member "(" fun_call_args ")" _END?
         | fun_call "(" fun_call_args ")" _END?

// Function definition
function : "fun" VAR_NAME "(" fun_args ")" fun_code_block
         | "fun" "(" FUN_OP ")" "(" fun_args ")" fun_code_block
         | "fun" VAR_NAME "(" fun_args ")" INTERNAL

FUN_OP : ("*" | "+" | "-" | "/" | "//" | "%" | "^" 
            | "in" | "[]" | "[::]" | "or" | "and" | "||" | "&&" | "!"  
            | "<=" | ">=" | ">" | "<" | "==" | "!=")

// Lambda function definition
lambda : "fun" VAR_NAME? "(" fun_args ")" "=" _rvalue

// Class constructor
constructor : "new" VAR_NAME "(" fun_args ")" fun_code_block
            | "new" VAR_NAME "(" fun_args ")" INTERNAL

// Block of code
code_block : "{" _stmt "}"

// Code allowed in function body
fun_code_block : code_block

// Constructs allowed in class body
_class_content : _END* constructor _END* _class_content
               | _stmt
//              | VAR_NAME
//              | assignment
//              | _definition
//              | _END
//              | _class_content _END+ _class_content _END*
//              |

// Constructs allowed in space body
//_space_conent : import 
//             | VAR_NAME 
//             | assignment
//             | _definition
//             | _END
//             | _space_conent _END+ _space_conent _END*
//             |

// Namespace definition
space : "space" VAR_NAME _END* "{" _END* _stmt _END* "}"
      //| "space" VAR_NAME INTERNAL
      //| "space" VAR_NAME INTERNAL "{" _END? _stmt _END? "}"

// Class definition
class : "class" VAR_NAME _END* "{" _END* _class_content _END* "}"
      | "class" VAR_NAME ":" var_list _END* "{" _END* _class_content _END* "}"
      
// Enum definition
enum : "enum" VAR_NAME _END* "{" _END* _enum_name_list _END* "}"

// Variable name
VAR_NAME : /(?!(if|elif|else|break|continue|do|while|for|import|internal|return|raise|as|finally|try|catch|nil|true|false|fun|class|space|in|or|and|not)\b)[a-zA-Z_][a-zA-Z0-9_]*/

_enum_name_list : VAR_NAME ","? 
                | _enum_name_list "," _END* VAR_NAME ","?
                |

typed_var : VAR_NAME ":" scope_name
          | VAR_NAME ":" type_list

type_list : "[" _type_list_val "]"

_type_list_val : VAR_NAME
               | _type_list_val "," VAR_NAME

// Variable in some scope
scope_name : _pscope_name

_pscope_name : "(" _pscope_name ")"
             | SCOPE _scope_no_glob //-> glob_var
             | NON_LOC _scope_no_glob //-> nonlocal_var
             | _scope_no_glob

_scope_no_glob : "(" _scope_no_glob ")"
               | _space_name
               | _dot_name
               | fun_call
               | VAR_NAME

// Space scope - for imports
space_scope : _pspace_scope

_pspace_scope : "(" _pspace_scope ")"
              | VAR_NAME
              | _pspace_scope SCOPE VAR_NAME

// Class member selection
_dot_name : _scope_no_glob DOT VAR_NAME
          | _expr DOT VAR_NAME

// Space member selection
_space_name : _scope_no_glob SCOPE VAR_NAME
            | _expr SCOPE VAR_NAME

// List of variables/ids
var_list : _scope_no_glob
         | var_list "," _scope_no_glob

// List of arguments allowed in function call
fun_call_args : _arg_list_call
              | arg_list_call_exp
              | _arg_list_call "," arg_list_call_exp
              |

_arg_list_call : (_expr|lambda)
              | _arg_list_call "," (_expr|lambda)

arg_list_call_exp : VAR_NAME "=" (_expr|lambda)
                  | arg_list_call_exp "," VAR_NAME "=" (_expr|lambda)

// Function args
fun_args : _arg_list_ndef
         | _arg_list_ndef "," var_args_list
         | arg_list
         | arg_list "," var_args_list
         | _arg_list_ndef "," arg_list
         | _arg_list_ndef "," arg_list "," var_args_list
         | var_args_list 
         |

// List of arguments without default values
_arg_list_ndef : VAR_NAME 
               | typed_var
               | _arg_list_ndef "," VAR_NAME
               | _arg_list_ndef "," typed_var

// List of arguments with possibility of default values
arg_list : VAR_NAME "=" (_expr|lambda)
         | typed_var "=" (_expr|lambda)
         | arg_list "," VAR_NAME "=" (_expr|lambda)
         | arg_list "," typed_var "=" (_expr|lambda)

// Variable amount of arguments
var_args_list : "*" VAR_NAME

// Constructs
construct : if       -> if
          | while    -> while
          | do_while -> do_while
          | for      -> for

// If statement
if : "if" "(" _expr ")" _END* (code_block|_stmts) _END* elif* _END* else? _END?
elif : "elif" "(" _expr ")" _END* (code_block|_stmts) _END*
else : "else" _END* (code_block|_stmts) _END*

// While
while : "while" "(" _expr ")" _END* (code_block|_stmts) _END?

// Do while
do_while : "do" _END* (code_block|_stmts) _END* "while" "(" _expr ")" _END?

// For loop
for : "for" "(" VAR_NAME ":" _expr ")" _END* (code_block|_stmts) _END?

return : "return" (_expr|lambda)?

raise : "raise" (_expr|lambda)

// Try
try: "try" _END* (code_block|_stmts) _END* (catch)+ finally?
catch: "catch" "(" (VAR_NAME | typed_var) ")" _END* (code_block | _stmts) _END*
finally: "finally" _END* (code_block|_stmts) _END* 

// Internal implementation comment
INTERNAL : "internal"

// One line comment
INL_COMMENT : /#[^\n]*/

// Hex int
HEX_INT : /0x[a-fA-F0-9]+/

// String
STRING : ESCAPED_STRING

// Just 1 dot, not 2
DOT : /(?<!\.)\.(?!\.)/

SCOPE : "::"

NON_LOC : "@"

// Flow control
FLOW_CTRL : ("continue" | "break")

// Statement _END
_END : NEWLINE
     | ";"

NUMBER : SIGNED_INT | SIGNED_FLOAT

CM_DECIMAL: INT DOT INT? | DOT INT
CM_EXP: ("e"|"E") SIGNED_INT

FLOAT: INT CM_EXP | CM_DECIMAL CM_EXP?

SIGNED_FLOAT: ["+"|"-"] FLOAT

%import common.WS_INLINE
%import common.CNAME
%import common.SIGNED_INT
%import common.INT
%import common.NEWLINE
%import common.C_COMMENT
%import common.ESCAPED_STRING

// Ignoring inline whitespaces and comments (not new lines)
%ignore WS_INLINE
%ignore INL_COMMENT
%ignore C_COMMENT
