// EBNF grammar for MASH language used by the parser
// @author: Marek Sedlacek

// Start nonterminal
start : stmt
      |

// Standalone expression
stmt : _stmts
     | END
     | stmt END+ stmt END*
     |

// Statements without ENDs
_stmts : import
       | rvalue
       | FLOW_CTRL
       | INTERNAL
       | assignment
       | definition
       | code_block
       | construct

// Importing
import : "import" VAR_NAME

// Value assignment excluding standalone variable (nil assignment)
assignment : scope_name ASSIGN_OP rvalue
           | VAR_NAME "=" INTERNAL

// Different assignments
ASSIGN_OP : ("="|"+="|"-="|"*="|"/="|"//="|"%="|"^=")

// List
list : expr "," expr ".." expr
     | expr ".." expr
     | "[" list_vals "]"
     | "[" (expr|lambda) ":" list_assig "]"
     | "[" (expr|lambda) "if" expr ":" list_assig "]"
list_vals : list_vals "," (expr|lambda)
          | (expr|lambda)
          |
list_assig : VAR_NAME "=" expr 
           | list_assig "," VAR_NAME "=" expr

// Dictionary
dict : "{" dict_val_list "}"
     | "{" "," "}" // Empty dict
dict_val_list : expr ":" expr
              | dict_val_list "," expr ":" expr

// Right side value
rvalue : silent_expr
       | expr
       | lambda

silent_expr : "~" expr

// Expressions using operators
expr : const
     | list
     | dict
     | scope_name
     | fun_call
     | member
     | ternary_if
     | "(" expr ")"
     | expr op_bin expr
     | OP_PLMIN expr
     | OP_UN_PRE expr
     | expr OP_UN_POST

// Binary and unary operator
op_bin : OP2_OR
       | OP2_AND
       | OP2_CMP
       | OP2_IN
       | OP2_ADDSUB
       | OP2_MULDIV
       | OP2_EXP

OP2_OR : ("||"|"or")
OP2_AND : ("&&"|"and")
OP_UN_PRE : ("!"|"not")
OP2_CMP : ("<="|">="|">"|"<"|"=="|"!=")
OP2_IN : "in"
OP2_ADDSUB : ("+"|"-")
OP2_MULDIV : ("*"|"/"|"//"|"%")
OP2_EXP : "^"
OP_UN_POST : ("++"|"--")
OP_PLMIN : ("+"|"-")

// Constants
const : NUMBER
      | HEX_INT
      | STRING
      | "nil"
      | "true"
      | "false"

// Ternary if
ternary_if : expr "?" (expr|lambda) ":" (expr|lambda)

// Member
member : expr "[" expr "]"
       | expr "[" expr? ":" expr? "]"
       | expr "[" expr? ":" expr? ":" expr? "]"

// Definitions
definition : lambda
           | function
           | space
           | class

// Function call
fun_call : scope_name "(" arg_list_call ")" END?
         | member "(" arg_list_call ")" END?
         | fun_call "(" arg_list_call ")" END?

// Lambda function definition
lambda : "fun" VAR_NAME? "(" arg_list ")" "=" (rvalue|INTERNAL)

// Function definition
function : "fun" VAR_NAME "(" arg_list ")" fun_code_block

// Class constructor
constructor : VAR_NAME "(" arg_list ")" code_block

// Block of code
code_block : "{" stmt "}"

// Code allowed in function body
fun_code_block : "{" stmt END "return" rvalue? END? "}"
               | "{" END? "return" rvalue? END? "}"
               | code_block

// Constructs allowed in class body
class_content : constructor
              | VAR_NAME
              | assignment
              | definition
              | END
              | class_content END+ class_content END*
              |

// Constructs allowed in space body
space_conent : import 
             | VAR_NAME 
             | assignment
             | definition
             | END
             | space_conent END+ space_conent END*
             |

// Namespace definition
space : "space" VAR_NAME? "{" END? space_conent END? "}"

// Class definition
class : "class" VAR_NAME "{" END? class_content END? "}"
      | "class" VAR_NAME ":" var_list "{" END? class_content END? "}"

// Variable name
VAR_NAME : /(?!(if|elif|else|break|continue|do|while|for|import|return|nil|true|false|fun|class|space|in|or|and|not)\b)[a-zA-Z_][a-zA-Z0-9_]*/

// Variable in some scope
scope_name : space_name
           | dot_name
           | fun_call
           | VAR_NAME

// Class member selection
dot_name : scope_name DOT VAR_NAME

// Space member selection
space_name : scope_name "::" VAR_NAME

// List of variables/ids
var_list : scope_name
         | var_list "," scope_name

// List of arguments allowed in function call
arg_list_call : (expr|lambda)
              | arg_list_call "," (expr|lambda)
              | arg_list_call "," arg_list_call_exp
              | arg_list_call_exp
              |

arg_list_call_exp : VAR_NAME "=" (expr|lambda)
                  | arg_list_call_exp "," VAR_NAME "=" (expr|lambda)

// List of arguments without default values
arg_list_ndef : VAR_NAME 
              | arg_list_ndef "," VAR_NAME 

// List of arguments with possibility of default values
arg_list : VAR_NAME "=" (expr|lambda)
         | arg_list_ndef "," VAR_NAME "=" (expr|lambda)
         | arg_list "," VAR_NAME "=" (expr|lambda)
         | arg_list_ndef
         |

// Constructs
construct : if
          | while
          | do_while
          | for

// If statement
if : "if" "(" expr ")" END* (code_block|_stmts) END* elif* END* else? END?
elif : "elif" "(" expr ")" END* (code_block|_stmts) END*
else : "else" END* (code_block|_stmts) END*

// While
while : "while" "(" expr ")" END* (code_block|_stmts) END?

// Do while
do_while : "do" END* (code_block|_stmts) END* "while" "(" expr ")" END?

// For loop
for : "for" "(" VAR_NAME ":" expr ")" END* (code_block|_stmts) END?

// Internal implementation comment
INTERNAL : /#[ \t]*\[![ \t]*internal[ \t]*!\][ \t]*/

// One line comment
INL_COMMENT : /#[^\n]*/

// Hex int
HEX_INT : /0x[a-fA-F0-9]+/

// String
STRING : ESCAPED_STRING
       | "f"ESCAPED_STRING
       | "r"ESCAPED_STRING

// Just 1 dot, not 2
DOT : /(?<!\.)\.(?!\.)/

// Flow control
FLOW_CTRL : ("continue" | "break" | "return")

// Statement end
END : NEWLINE
    | ";"

NUMBER : SIGNED_INT | SIGNED_FLOAT

CM_DECIMAL: INT DOT INT? | DOT INT
CM_EXP: ("e"|"E") SIGNED_INT

FLOAT: INT CM_EXP | CM_DECIMAL CM_EXP?

SIGNED_FLOAT: ["+"|"-"] FLOAT

%import common.WS_INLINE
%import common.CNAME
%import common.SIGNED_INT
%import common.INT
%import common.NEWLINE
%import common.C_COMMENT
%import common.ESCAPED_STRING

// Ignoring inline whitespaces and comments (not new lines)
%ignore WS_INLINE
%ignore INL_COMMENT
%ignore C_COMMENT