// EBNF grammar for MASH language used by the parser
// @author: Marek Sedlacek

// Start nonterminal
start : _stmt
      |

// Standalone expression
_stmt : _stmts
      | _END
      | _stmt _END+ _stmt _END*
      |

// Statements without ENDs
_stmts : import
       | _rvalue
       | FLOW_CTRL
       | return
       | assignment
       | op_assign
       | _definition
       | code_block
       | construct

// Importing
import : "import" VAR_NAME

// Value assignment excluding standalone variable (nil assignment)
assignment : scope_name "=" (_expr|lambda|assignment)
           | VAR_NAME "=" INTERNAL

// Operation and assignment over 1 variable
op_assign : scope_name ASSIGN_OP (_expr|lambda)

// Different assignments
ASSIGN_OP : ("+="|"-="|"*="|"/="|"//="|"%="|"^=")

// List
list : _expr "," _expr ".." _expr -> range
     | _expr ".." _expr -> range
     | "[" _list_vals "]"
     | "[" (_expr|lambda) ":" list_assig "]"  // List comprehension
     | "[" (_expr|lambda) "if" _expr ":" list_assig "]"  // List comprehension with condition
_list_vals : _list_vals "," (_expr|lambda)
           | (_expr|lambda)
           |
list_assig : VAR_NAME "=" _expr 
           | list_assig "," VAR_NAME "=" _expr

// Dictionary
dict : "{" _dict_val_list "}"
     | "{" "," "}" // Empty dict
_dict_val_list : (_expr|lambda) ":" (_expr|lambda)
              | _dict_val_list "," (_expr|lambda) ":" (_expr|lambda)

// Right side value
_rvalue : silent_expr
        | _expr
        | lambda

silent_expr : "~" _expr

// Expressions using operators
_expr : expr_or
     | expr_and
     | expr_not
     | expr_lte
     | expr_gte
     | expr_gt
     | expr_lt
     | expr_eq
     | expr_neq
     | expr_in
     | expr_add
     | expr_sub
     | expr_mul
     | expr_fdiv
     | expr_idiv
     | expr_mod
     | expr_exp
     | expr_inc
     | expr_dec
     | ternary_if
     | fun_call
     | member
     | scope_name
     | const
     | list
     | dict
     | "(" _expr ")"

expr_or : _expr ("||"|"or") _expr
expr_and : _expr ("&&"|"and") _expr
expr_not : ("!"|"not") _expr
expr_lte : _expr "<=" _expr
expr_gte : _expr ">=" _expr
expr_gt : _expr ">" _expr
expr_lt : _expr "<" _expr
expr_eq : _expr "==" _expr
expr_neq : _expr "!=" _expr
expr_in : _expr "in" _expr
expr_add : _expr "+"_expr
expr_sub : _expr "-" _expr
expr_mul : _expr "*" _expr
expr_fdiv : _expr "/" _expr
expr_idiv : _expr "//" _expr
expr_mod : _expr "%" _expr
expr_exp : _expr "^" _expr
expr_inc : _expr "++"
expr_dec : _expr "--"

// Constants
const : SIGNED_FLOAT  -> float
      | SIGNED_INT -> int
      | HEX_INT -> hex_int
      | STRING  -> string
      | "r"STRING -> rstring
      | "f"STRING -> fstring
      | "nil"   -> nil
      | "true"  -> true
      | "false" -> false

// Ternary if
ternary_if : _expr "?" (_expr|lambda) ":" (_expr|lambda)
           //| "if" "(" _expr ")" (_expr|lambda) "else" (_expr|lambda) // Is the same as normal if

// Member
member : _expr "[" _expr "]"
       | _expr "[" _expr? MEM_SEP _expr? "]" -> slice
       | _expr "[" _expr? MEM_SEP _expr? MEM_SEP _expr? "]" -> slice

MEM_SEP : ":"

// Definitions
_definition : lambda
           | function
           | space
           | class

// Function call
fun_call : scope_name "(" fun_call_args ")" _END?
         | member "(" fun_call_args ")" _END?
         | fun_call "(" fun_call_args ")" _END?

// Function definition
function : "fun" VAR_NAME "(" fun_args ")" fun_code_block
         | "fun" VAR_NAME "(" fun_args ")" INTERNAL

// Lambda function definition
lambda : "fun" VAR_NAME? "(" fun_args ")" "=" _rvalue

// Class constructor
constructor : VAR_NAME "(" fun_args ")" code_block

// Block of code
code_block : "{" _stmt "}"

// Code allowed in function body
fun_code_block : code_block

// Constructs allowed in class body
//_class_content : constructor
//              | VAR_NAME
//              | assignment
//              | _definition
//              | _END
//              | _class_content _END+ _class_content _END*
//              |

// Constructs allowed in space body
//_space_conent : import 
//             | VAR_NAME 
//             | assignment
//            | _definition
//             | _END
//             | _space_conent _END+ _space_conent _END*
//             |

// Namespace definition
space : "space" VAR_NAME "{" _END? _stmt _END? "}"
      | "space" VAR_NAME INTERNAL
      | "space" VAR_NAME INTERNAL "{" _END? _stmt _END? "}"

// Class definition
class : "class" VAR_NAME INTERNAL? "{" _END? _stmt _END? "}"
      | "class" VAR_NAME ":" var_list "{" _END? _stmt _END? "}"
      | "class" VAR_NAME INTERNAL

// Variable name
VAR_NAME : /(?!(if|elif|else|break|continue|do|while|for|import|internal|return|nil|true|false|fun|class|space|in|or|and|not)\b)[a-zA-Z_][a-zA-Z0-9_]*/

// Variable in some scope
scope_name : _space_name
           | _dot_name
           | fun_call
           | VAR_NAME

// Class member selection
_dot_name : scope_name DOT VAR_NAME

// Space member selection
_space_name : scope_name SCOPE VAR_NAME

// List of variables/ids
var_list : scope_name
         | var_list "," scope_name

// List of arguments allowed in function call
fun_call_args : _arg_list_call
              | arg_list_call_exp
              | _arg_list_call "," arg_list_call_exp
              |

_arg_list_call : (_expr|lambda)
              | _arg_list_call "," (_expr|lambda)

arg_list_call_exp : VAR_NAME "=" (_expr|lambda)
                  | arg_list_call_exp "," VAR_NAME "=" (_expr|lambda)

// Function call
fun_args : _arg_list_ndef
         | arg_list
         | _arg_list_ndef "," arg_list
         |

// List of arguments without default values
_arg_list_ndef : VAR_NAME 
              | _arg_list_ndef "," VAR_NAME 

// List of arguments with possibility of default values
arg_list : VAR_NAME "=" (_expr|lambda)
         | arg_list "," VAR_NAME "=" (_expr|lambda)

// Constructs
construct : if       -> if
          | while    -> while
          | do_while -> do_while
          | for      -> for

// If statement
if : "if" "(" _expr ")" _END* (code_block|_stmts) _END* elif* _END* else? _END?
elif : "elif" "(" _expr ")" _END* (code_block|_stmts) _END*
else : "else" _END* (code_block|_stmts) _END*

// While
while : "while" "(" _expr ")" _END* (code_block|_stmts) _END?

// Do while
do_while : "do" _END* (code_block|_stmts) _END* "while" "(" _expr ")" _END?

// For loop
for : "for" "(" VAR_NAME ":" _expr ")" _END* (code_block|_stmts) _END?

return : "return" _rvalue?

// Internal implementation comment
INTERNAL : "internal"

// One line comment
INL_COMMENT : /#[^\n]*/

// Hex int
HEX_INT : /0x[a-fA-F0-9]+/

// String
STRING : ESCAPED_STRING

// Just 1 dot, not 2
DOT : /(?<!\.)\.(?!\.)/

SCOPE : "::"

// Flow control
FLOW_CTRL : ("continue" | "break")

// Statement _END
_END : NEWLINE
    | ";"

NUMBER : SIGNED_INT | SIGNED_FLOAT

CM_DECIMAL: INT DOT INT? | DOT INT
CM_EXP: ("e"|"E") SIGNED_INT

FLOAT: INT CM_EXP | CM_DECIMAL CM_EXP?

SIGNED_FLOAT: ["+"|"-"] FLOAT

%import common.WS_INLINE
%import common.CNAME
%import common.SIGNED_INT
%import common.INT
%import common.NEWLINE
%import common.C_COMMENT
%import common.ESCAPED_STRING

// Ignoring inline whitespaces and comments (not new lines)
%ignore WS_INLINE
%ignore INL_COMMENT
%ignore C_COMMENT
